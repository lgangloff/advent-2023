/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.example;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.LongStream;
import java.util.stream.Stream;


import org.advent.MainApp;
import org.advent.Utils;


public class App implements MainApp{
    

    public static void main(String[] args) throws Exception {
        Utils.DEBUG = true;
        Utils.main(new App());
    }
    
    
    TransformerBuilder builder = null;
    public void run() throws Exception {
        Alamach alamach = new Alamach();


        Utils.start("day5", "data1.in", line->{
            if (alamach.seeds==null){
                List<Long> seedsNumber = Stream.of(line.substring("seeds: ".length())
                    .split(" "))
                    .map(String::trim).map(Long::valueOf).toList();

                for (int i = 0; i < seedsNumber.size(); i=i+2) {
                    alamach.addSeeds(
                        LongStream.range(
                        seedsNumber.get(i),
                        seedsNumber.get(i)+seedsNumber.get(i+1))
                        .mapToObj(Quantity::ofSeed)
                    );
                }
            }
            else if (!line.isBlank()){

                if (line.endsWith("map:")){
                    builder = TransformerBuilder.of(line);
                }
                else{
                    alamach.transformers.add(builder.parse(line));
                }
            }

        });

        alamach.prepare();


        Utils.debug(alamach.transformers.size());

        
        Optional<Quantity> result = alamach.seeds.parallel()
            .map(alamach::transform)
            .reduce(Quantity::min);

        
        Utils.debug(result);
    }


    static class Alamach{
        Stream<Quantity> seeds = null;
        List<Transformer> transformers = new ArrayList<>();
        Map<Type, List<Transformer>> transformersByType = new HashMap<>();

        public void prepare(){
            this.transformersByType = transformers.stream().collect(
                Collectors.groupingBy(Transformer::getFrom));
        }

        public void addSeeds(Stream<Quantity> stream){
            this.seeds = Stream.concat(this.seeds==null ? Stream.empty() : this.seeds, stream);
        }

        public Quantity transform(Quantity actual){
            final Quantity result = actual;
            while (result.type != Type.LOCATION) {
                Optional<Transformer> opt = transformersByType.get(result.type)
                    .stream().filter(t-> 
                        t.sourceRangeStart <= result.value 
                        && result.value <= (t.sourceRangeStart+t.rangeLenght))
                    .findFirst();
                if (opt.isPresent()){
                    opt.get().transform(result);
                }
                else{
                    result.type = TransformerBuilder.DEFAULT_TRANSFORMER.get(result.type);
                }
            }
            return result;
        }
    }
    
    static class Quantity {

        public Quantity(Type type, long value) {
            this.value = value;
            this.type = type;
        }
        long value;
        Type type;

        static final Quantity min(Quantity a, Quantity b){
            return a.value < b.value ? a : b;
        }
        private static final Quantity ofSeed(long value){
            return new Quantity(Type.SEED, value);
        }

        @Override
        public String toString() {
            return type + " [value=" + value  + "]";
        }
        
        
    }

    static class TransformerBuilder{
        Type from;
        Type to;
        static final Map<Type, Type> DEFAULT_TRANSFORMER = new HashMap();
        static final TransformerBuilder of(String line){
            String cleaned = line.replaceAll("-to-", " ");
            cleaned = cleaned.replaceAll(" map:", "");
            cleaned = cleaned.toUpperCase();
            String[] res = cleaned.split(" ");

            TransformerBuilder builder = new TransformerBuilder();
            builder.from = Type.valueOf(res[0]);
            builder.to = Type.valueOf(res[1]);

            DEFAULT_TRANSFORMER.putIfAbsent(builder.from, builder.to);

            return builder;
        }

        Transformer parse(String line){
            Transformer t = new Transformer();
            t.from = this.from;
            t.to = this.to;
            String[] res = line.split(" ");
            t.destinationRangeStart = Long.valueOf(res[0]);
            t.sourceRangeStart = Long.valueOf(res[1]);
            t.rangeLenght = Long.valueOf(res[2]);
            return t;
        }
    }
    static class Transformer{
        Type from;
        Type to;
        long destinationRangeStart;
        long sourceRangeStart;
        long rangeLenght;
        @Override
        public String toString() {
            return "Transformer [from=" + from + ", to=" + to + ", destinationRangeStart=" + destinationRangeStart
                    + ", sourceRangeStart=" + sourceRangeStart + ", rangeLenght=" + rangeLenght + "]";
        }

        public void transform(Quantity result) {
            result.value = result.value + (this.destinationRangeStart-this.sourceRangeStart); 
            result.type = this.to;
        }

        public Type getFrom(){
            return this.from;
        }
        
    }

    enum Type{
        SEED, SOIL, FERTILIZER, WATER, LIGHT, TEMPERATURE, HUMIDITY, LOCATION
    }
}

