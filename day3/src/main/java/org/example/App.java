/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.example;

import static org.example.App.Position.BOTTOM;
import static org.example.App.Position.LEFT;
import static org.example.App.Position.RIGHT;
import static org.example.App.Position.TOP;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.advent.MainApp;
import org.advent.Utils;


public class App implements MainApp{
    

    public static void main(String[] args) throws Exception {
        Utils.DEBUG = false;
        Utils.main(new App());
    }
    
    public void run1() throws Exception {
        
        Engine map = new Engine();
        
        Utils.start("day3", "data0.in", line->{
            map.addLine(line);
        });

        if (Utils.DEBUG){
            Utils.debug(map);

            List<Point> symbols = map.points.stream().filter(Point::isSymbol).toList();
    
            for (Point symbol : symbols) {
                Utils.debug(symbol + "=>" + symbol.arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct().map(Number::getValue).toList());
            }    
        }

        int sum = map.points.stream()
            .filter(Point::isSymbol)
            .flatMap(Point::arroundPoints)
            .filter(Point::isDigit)
            .map(Point::getNumber)
            .distinct()
            .collect(Collectors.summingInt(Number::getValue));
            
        System.out.println("Sum=" + sum);

    }
    
    public void run() throws Exception {
        
        Engine map = new Engine();
        
        Utils.start("day3", "data1.in", line->{
            map.addLine(line);
        });

        if (Utils.DEBUG){
            Utils.debug(map);

            List<Point> symbols = map.points.stream().filter(Point::isSymbol).toList();
    
            for (Point symbol : symbols) {
                Utils.debug(symbol + "=>" + symbol.arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct().map(Number::getValue).toList());
            }    
            
            Utils.debug("GEAR\n");
            List<Point> gears = map.points.stream()
                .filter(Point::isGear).toList();
    
            for (Point symbol : gears) {
                Utils.debug(symbol + "=>" + symbol.arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct().map(Number::getValue).toList());
            }    

            var res = map.points.stream()
            .filter(Point::isGear)
            .map(gear->gear.arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct())
            .map(numbers->numbers.map(Number::getValue).reduce(1, (t, u) -> t * u)).toList();
            Utils.debug("res="+res);
        }
            
        int sumOfGear = map.points.stream()
            .filter(Point::isGear)
            .map(gear->gear.arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct())
            .map(numbers->numbers.map(Number::getValue).reduce(1, (t, u) -> t * u))
            .reduce(0, Integer::sum);

        System.out.println("Sum=" + sumOfGear);

    }

    static class Engine {
        final List<Point> points = new ArrayList<>();

        public void addLine(String line){
            List<Point> newPoints = line.chars().mapToObj(i->(char)i).map(Point::new).toList();
            List<Point> previousPoints = points.isEmpty() ? null : points.subList(points.size()-newPoints.size(), points.size());
            Number number = new Number();
            for (int i = 0; i < newPoints.size()-1; i++) {
                Point left = newPoints.get(i);
                Point right = newPoints.get(i+1);
                left.link(Position.RIGHT, right);
                right.link(Position.LEFT, left);
                if (previousPoints != null){
                    Point top = previousPoints.get(i);
                    Point bottom = newPoints.get(i);
                    top.link(Position.BOTTOM, bottom);
                    bottom.link(Position.TOP, top);
                }

                if (left.isDigit()){
                    number.addPoint(left);
                    if (right.isDigit()){
                        number.addPoint(right);
                    }
                    else{
                        number = new Number();
                    }
                }
                
            }
            this.points.addAll(newPoints);
        }

        @Override
        public String toString() {
            return "Engine [points=" + points + "]";
        }
    }

    static class Point{
        final char value;
        Map<Position, Point> adjacents = new HashMap<>(4);
        Number number;
        Point(char c){
            this.value = c;
        }
        public void link(Position position, Point point) {
            adjacents.put(position, point);
        }
        @Override
        public String toString() {
            return value+"";
        }

        public Number getNumber(){
            return this.number;
        }
        public boolean isGear(){
            return this.value == '*' && arroundPoints().filter(Point::isDigit).map(Point::getNumber).distinct().count() == 2;
        }
        public boolean isDigit(){
            return Character.isDigit(value);
        }
        public int getDigit(){
            return Character.digit(value, 10);
        }        
        public boolean isEmpty(){
            return this.value == '.';
        }
        public boolean isSymbol(){
            return !isEmpty() && !isDigit();
        }
        public Optional<Point> adjacent(Position p){
            return Optional.ofNullable(adjacents.get(p));
        }
        public Optional<Point> adjacent(Position p, Position p2){
            return adjacent(p).flatMap(r->r.adjacent(p2));
        }
        public Stream<Point> arroundPoints(){
            return Stream.of(
                adjacent(TOP, LEFT), adjacent(TOP), adjacent(TOP, RIGHT),
                adjacent(LEFT), adjacent(RIGHT),
                adjacent(BOTTOM, LEFT), adjacent(BOTTOM), adjacent(BOTTOM, RIGHT))
                .filter(Optional::isPresent)
                .map(Optional::get);
        } 
    }

    static class Number{
        Set<Point> points = new LinkedHashSet<>();

        public void addPoint(Point p){
            this.points.add(p);
            p.number = this;
        }   
        public int getValue(){
            return Integer.parseInt(this.points.stream().sequential().map(p->p.value+"").collect(Collectors.joining()));
        }     
    }

    static enum Position{
        TOP, LEFT, BOTTOM, RIGHT,
    }

}

